/**\n * Subscription Management Routes\n * Handles subscription lifecycle, upgrades, billing, and usage tracking\n */\n\nimport { Express, Request, Response } from 'express';\nimport { db } from '../db';\nimport { organizations, subscriptionPlans, users } from '@shared/schema';\nimport { eq } from 'drizzle-orm';\nimport {\n  requireActiveSubscription,\n  enforceMultiTenancy,\n  requireOrgRole,\n} from '../middleware/subscriptionAndTenancyMiddleware';\nimport { StripeBillingService } from '../services/stripeBillingService';\nimport {\n  SUBSCRIPTION_TIERS,\n  getTierConfig,\n  getTierFeatures,\n} from '../constants/subscriptionTiers';\n\nexport function registerSubscriptionRoutes(app: Express): void {\n  /**\n   * GET /api/subscription/current\n   * Get current subscription details for authenticated user's organization\n   */\n  app.get(\n    '/api/subscription/current',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n\n        if (!subscription) {\n          return res.status(404).json({\n            error: 'SUBSCRIPTION_NOT_FOUND',\n            message: 'No subscription found',\n          });\n        }\n\n        const tierConfig = getTierConfig(subscription.subscriptionTier);\n\n        res.json({\n          subscription: {\n            organizationId: subscription.organizationId,\n            organizationName: subscription.organizationName,\n            tier: subscription.subscriptionTier,\n            status: subscription.subscriptionStatus,\n            billingCycle: subscription.billingCycle,\n            monthlyPrice: tierConfig.monthlyPrice,\n            annualPrice: tierConfig.annualPrice,\n            currency: tierConfig.currency,\n            features: subscription.features,\n            limits: {\n              residents: subscription.maxResidents,\n              properties: subscription.maxProperties,\n              currentResidents: subscription.currentResidentCount,\n              currentProperties: subscription.currentPropertyCount,\n              residentUsagePercent: subscription.residentUsagePercent,\n              propertyUsagePercent: subscription.propertyUsagePercent,\n            },\n            dates: {\n              startDate: subscription.subscriptionStartDate,\n              endDate: subscription.subscriptionEndDate,\n              trialEndDate: subscription.trialEndDate,\n              nextBillingDate: subscription.nextBillingDate,\n            },\n            userRole: subscription.userRole,\n            isAdmin: subscription.isOrgAdmin,\n            alerts: {\n              residentCapacityAlert: subscription.hasResidentUsageAlert,\n              propertyCapacityAlert: subscription.hasPropertyUsageAlert,\n            },\n          },\n        });\n      } catch (error) {\n        console.error('Error fetching subscription:', error);\n        res.status(500).json({\n          error: 'FETCH_FAILED',\n          message: 'Failed to fetch subscription details',\n        });\n      }\n    }\n  );\n\n  /**\n   * GET /api/subscription/plans\n   * List all available subscription plans\n   */\n  app.get('/api/subscription/plans', async (req: Request, res: Response) => {\n    try {\n      const plans = await db\n        .select()\n        .from(subscriptionPlans)\n        .where(eq(subscriptionPlans.isActive, true))\n        .orderBy(subscriptionPlans.displayOrder);\n\n      res.json({\n        plans: plans.map(plan => ({\n          tier: plan.tier,\n          name: plan.name,\n          description: plan.description,\n          pricing: {\n            monthly: plan.monthlyPrice,\n            annual: plan.annualPrice,\n            currency: plan.currency,\n            savings: (\n              (1 - (plan.annualPrice * 12) / (plan.monthlyPrice * 12)) *\n              100\n            ).toFixed(0) + '%',\n          },\n          limits: {\n            residents: plan.maxResidents === -1 ? 'Unlimited' : plan.maxResidents,\n            properties: plan.maxProperties === -1 ? 'Unlimited' : plan.maxProperties,\n          },\n          features: plan.features,\n          supportLevel: plan.supportLevel,\n          supportHours: plan.supportHours,\n          stripePriceIds: {\n            monthly: plan.stripePriceIdMonthly,\n            annual: plan.stripePriceIdAnnual,\n          },\n        })),\n      });\n    } catch (error) {\n      console.error('Error fetching plans:', error);\n      res.status(500).json({\n        error: 'FETCH_FAILED',\n        message: 'Failed to fetch subscription plans',\n      });\n    }\n  });\n\n  /**\n   * POST /api/subscription/upgrade\n   * Upgrade organization to higher tier\n   */\n  app.post(\n    '/api/subscription/upgrade',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    requireOrgRole('admin'),\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const { newTier, billingCycle = 'monthly' } = req.body;\n\n        if (!newTier) {\n          return res.status(400).json({\n            error: 'INVALID_REQUEST',\n            message: 'newTier is required',\n          });\n        }\n\n        const tierHierarchy = {\n          trial: 0,\n          starter: 1,\n          professional: 2,\n          enterprise: 3,\n        };\n\n        const currentLevel = tierHierarchy[subscription?.subscriptionTier as keyof typeof tierHierarchy] ?? 0;\n        const newLevel = tierHierarchy[newTier as keyof typeof tierHierarchy];\n\n        if (!newLevel || newLevel <= currentLevel) {\n          return res.status(400).json({\n            error: 'INVALID_UPGRADE',\n            message: 'New tier must be higher than current tier',\n          });\n        }\n\n        await StripeBillingService.upgradeSubscription(\n          subscription!.organizationId,\n          newTier,\n          billingCycle\n        );\n\n        res.json({\n          success: true,\n          message: `Upgraded to ${newTier} tier`,\n          subscription: {\n            tier: newTier,\n            billingCycle,\n            status: 'active',\n          },\n        });\n      } catch (error) {\n        console.error('Upgrade error:', error);\n        res.status(500).json({\n          error: 'UPGRADE_FAILED',\n          message: 'Failed to upgrade subscription',\n        });\n      }\n    }\n  );\n\n  /**\n   * POST /api/subscription/downgrade\n   * Downgrade organization to lower tier\n   */\n  app.post(\n    '/api/subscription/downgrade',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    requireOrgRole('admin'),\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const { newTier, billingCycle = 'monthly' } = req.body;\n\n        if (!newTier) {\n          return res.status(400).json({\n            error: 'INVALID_REQUEST',\n            message: 'newTier is required',\n          });\n        }\n\n        const tierHierarchy = {\n          trial: 0,\n          starter: 1,\n          professional: 2,\n          enterprise: 3,\n        };\n\n        const currentLevel = tierHierarchy[subscription?.subscriptionTier as keyof typeof tierHierarchy] ?? 0;\n        const newLevel = tierHierarchy[newTier as keyof typeof tierHierarchy];\n\n        if (!newLevel || newLevel >= currentLevel) {\n          return res.status(400).json({\n            error: 'INVALID_DOWNGRADE',\n            message: 'New tier must be lower than current tier',\n          });\n        }\n\n        const newTierConfig = getTierConfig(newTier as any);\n\n        // Warn if over new limits\n        const warnings = [];\n        if (\n          subscription!.currentResidentCount > newTierConfig.limits.maxResidents &&\n          newTierConfig.limits.maxResidents > 0\n        ) {\n          warnings.push(\n            `Current resident count (${subscription!.currentResidentCount}) exceeds new limit (${newTierConfig.limits.maxResidents})`\n          );\n        }\n        if (\n          subscription!.currentPropertyCount > newTierConfig.limits.maxProperties &&\n          newTierConfig.limits.maxProperties > 0\n        ) {\n          warnings.push(\n            `Current property count (${subscription!.currentPropertyCount}) exceeds new limit (${newTierConfig.limits.maxProperties})`\n          );\n        }\n\n        await StripeBillingService.downgradeSubscription(\n          subscription!.organizationId,\n          newTier,\n          billingCycle\n        );\n\n        res.json({\n          success: true,\n          message: `Downgraded to ${newTier} tier`,\n          warnings: warnings.length > 0 ? warnings : undefined,\n          subscription: {\n            tier: newTier,\n            billingCycle,\n            status: 'active',\n          },\n        });\n      } catch (error) {\n        console.error('Downgrade error:', error);\n        res.status(500).json({\n          error: 'DOWNGRADE_FAILED',\n          message: 'Failed to downgrade subscription',\n        });\n      }\n    }\n  );\n\n  /**\n   * GET /api/subscription/billing-portal\n   * Get Stripe billing portal URL\n   */\n  app.get(\n    '/api/subscription/billing-portal',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    requireOrgRole('admin'),\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const returnUrl = req.query.returnUrl as string || `${process.env.FRONTEND_URL || 'http://localhost:3000'}/app/settings/billing`;\n\n        const portalUrl = await StripeBillingService.createBillingPortalSession(\n          subscription!.organizationId,\n          returnUrl\n        );\n\n        res.json({\n          portalUrl,\n        });\n      } catch (error) {\n        console.error('Billing portal error:', error);\n        res.status(500).json({\n          error: 'PORTAL_ERROR',\n          message: 'Failed to create billing portal session',\n        });\n      }\n    }\n  );\n\n  /**\n   * GET /api/subscription/usage\n   * Get current resource usage statistics\n   */\n  app.get(\n    '/api/subscription/usage',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const tierConfig = getTierConfig(subscription!.subscriptionTier);\n\n        res.json({\n          usage: {\n            residents: {\n              current: subscription!.currentResidentCount,\n              max: subscription!.maxResidents,\n              percent: subscription!.residentUsagePercent,\n              canAddMore: subscription!.maxResidents < 0 || subscription!.currentResidentCount < subscription!.maxResidents,\n            },\n            properties: {\n              current: subscription!.currentPropertyCount,\n              max: subscription!.maxProperties,\n              percent: subscription!.propertyUsagePercent,\n              canAddMore: subscription!.maxProperties < 0 || subscription!.currentPropertyCount < subscription!.maxProperties,\n            },\n            alerts: {\n              residentUsageAlert: subscription!.hasResidentUsageAlert,\n              propertyUsageAlert: subscription!.hasPropertyUsageAlert,\n            },\n            thresholds: {\n              warning: 80,\n              critical: 95,\n            },\n          },\n          recommendations: {\n            suggestUpgrade: subscription!.residentUsagePercent > 80 || subscription!.propertyUsagePercent > 80,\n            upgradeTo: subscription!.residentUsagePercent > 80 || subscription!.propertyUsagePercent > 80\n              ? subscription!.subscriptionTier === 'trial' || subscription!.subscriptionTier === 'starter'\n                ? 'professional'\n                : 'enterprise'\n              : null,\n          },\n        });\n      } catch (error) {\n        console.error('Usage error:', error);\n        res.status(500).json({\n          error: 'USAGE_FETCH_FAILED',\n          message: 'Failed to fetch usage statistics',\n        });\n      }\n    }\n  );\n\n  /**\n   * GET /api/organization\n   * Get organization details\n   */\n  app.get(\n    '/api/organization',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const org = await db\n          .select()\n          .from(organizations)\n          .where(eq(organizations.id, subscription!.organizationId))\n          .limit(1);\n\n        if (org.length === 0) {\n          return res.status(404).json({\n            error: 'ORG_NOT_FOUND',\n            message: 'Organization not found',\n          });\n        }\n\n        const organization = org[0];\n\n        res.json({\n          organization: {\n            id: organization.id,\n            name: organization.name,\n            displayName: organization.displayName,\n            type: organization.organizationType,\n            email: organization.email,\n            phone: organization.phone,\n            address: organization.address,\n            branding: organization.branding,\n            settings: organization.settings,\n            subscription: {\n              tier: organization.subscriptionTier,\n              status: organization.subscriptionStatus,\n              billingCycle: organization.billingCycle,\n              dates: {\n                start: organization.subscriptionStartDate,\n                end: organization.subscriptionEndDate,\n                trialEnd: organization.trialEndDate,\n                nextBilling: organization.nextBillingDate,\n              },\n            },\n          },\n        });\n      } catch (error) {\n        console.error('Organization fetch error:', error);\n        res.status(500).json({\n          error: 'FETCH_FAILED',\n          message: 'Failed to fetch organization details',\n        });\n      }\n    }\n  );\n\n  /**\n   * PUT /api/organization\n   * Update organization details (admin only)\n   */\n  app.put(\n    '/api/organization',\n    requireActiveSubscription,\n    enforceMultiTenancy,\n    requireOrgRole('admin'),\n    async (req: Request, res: Response) => {\n      try {\n        const { subscription } = req;\n        const { displayName, email, phone, address, branding, settings } = req.body;\n\n        const updateData: any = {};\n        if (displayName !== undefined) updateData.displayName = displayName;\n        if (email !== undefined) updateData.email = email;\n        if (phone !== undefined) updateData.phone = phone;\n        if (address !== undefined) updateData.address = address;\n        if (branding !== undefined) updateData.branding = branding;\n        if (settings !== undefined) updateData.settings = settings;\n        updateData.updatedAt = new Date();\n\n        await db\n          .update(organizations)\n          .set(updateData)\n          .where(eq(organizations.id, subscription!.organizationId));\n\n        res.json({\n          success: true,\n          message: 'Organization updated successfully',\n        });\n      } catch (error) {\n        console.error('Organization update error:', error);\n        res.status(500).json({\n          error: 'UPDATE_FAILED',\n          message: 'Failed to update organization',\n        });\n      }\n    }\n  );\n}\n"