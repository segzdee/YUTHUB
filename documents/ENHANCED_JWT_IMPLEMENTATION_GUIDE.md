# Enhanced JWT with Tenant Context Implementation Guide\n\n## Overview\n\nThis implementation embeds subscription tier, organization details, and role information in JWT tokens, enabling efficient access control and multi-tenancy enforcement without additional database queries.\n\n## Architecture\n\n### Components\n\n#### 1. Enhanced JWT Service (`server/services/enhancedJwtService.ts`)\n\n**Purpose**: Core JWT management with tenant context loading\n\n**Key Methods**:\n- `loadTenantContext(userId)`: Async - loads user's organization memberships, subscription tier, and features\n- `generateTokenPairWithContext(userId)`: Async - creates access + refresh tokens with full tenant context\n- `generateAccessToken(payload)`: Sync - creates access token from payload\n- `generateRefreshToken(userId)`: Sync - creates refresh token\n- `verifyAccessToken(token)`: Validates and decodes access token\n- `verifyRefreshToken(token)`: Validates and decodes refresh token\n- `refreshAccessToken(refreshToken)`: Async - refreshes with fresh tenant context\n\n**Token Payload Structure**:\n```typescript\ninterface EnhancedTokenPayload {\n  userId: string;\n  email: string;\n  role: string;                    // Primary organization role\n  primaryOrganizationId: number;\n  organizationName: string;\n  subscriptionTier: string;        // e.g., 'free', 'professional', 'enterprise'\n  subscriptionStatus: string;      // e.g., 'active', 'trialing', 'canceled'\n  features: Record<string, boolean>; // Feature flags per subscription tier\n  organizations: Array<{           // All orgs user belongs to\n    organizationId: number;\n    organizationName: string;\n    role: string;\n    isPrimary: boolean;\n  }>;\n  tenantId?: string;               // Legacy compatibility\n  sessionId?: string;              // Optional for session tracking\n}\n```\n\n#### 2. Enhanced Auth Middleware (`server/middleware/enhancedAuthMiddleware.ts`)\n\n**Purpose**: Middleware chain for authentication and authorization\n\n**Key Middleware**:\n- `extractTokenMiddleware`: Extracts and validates JWT, populates request context\n- `requireAuth`: Enforces authentication\n- `requireRole(allowedRoles)`: Enforces role-based access\n- `requireActiveSubscription`: Checks subscription status\n- `requireFeature(featureName)`: Checks feature availability\n- `checkOrganizationAccess`: Validates organization membership\n- `handleTokenRefresh`: Automatic token refresh from cookies\n- `tenantContextMiddleware`: Injects tenant context into all requests\n\n**Request Extensions**:\n```typescript\nreq.user: EnhancedTokenPayload;           // Full decoded token\nreq.userId: string;                       // User ID from token\nreq.organizationId: number;               // Current organization context\nreq.userRole: string;                     // User role in org\nreq.subscriptionTier: string;             // Organization subscription tier\nreq.subscriptionStatus: string;           // Subscription status\nreq.tenantContext: {                      // All organizations context\n  primaryOrganizationId: number;\n  organizations: Array<{...}>;\n};\n```\n\n## Database Schema Requirements\n\n### Required Tables\n\n#### `users`\n```sql\nCREATE TABLE users (\n  id VARCHAR(255) PRIMARY KEY,\n  email VARCHAR(255) UNIQUE NOT NULL,\n  -- ... other fields\n);\n```\n\n#### `organizations`\n```sql\nCREATE TABLE organizations (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  subscription_tier VARCHAR(50) NOT NULL,\n  subscription_status VARCHAR(50) NOT NULL,\n  features_enabled JSONB,\n  -- ... other fields\n);\n```\n\n#### `user_organizations`\n```sql\nCREATE TABLE user_organizations (\n  user_id VARCHAR(255) NOT NULL,\n  organization_id INTEGER NOT NULL,\n  role VARCHAR(50) NOT NULL,\n  is_primary BOOLEAN DEFAULT false,\n  is_active BOOLEAN DEFAULT true,\n  status VARCHAR(50) DEFAULT 'active',\n  created_at TIMESTAMP DEFAULT now(),\n  PRIMARY KEY (user_id, organization_id),\n  FOREIGN KEY (user_id) REFERENCES users(id),\n  FOREIGN KEY (organization_id) REFERENCES organizations(id)\n);\n```\n\n## Integration Steps\n\n### Step 1: Configure Environment Variables\n\nAdd to `.env.local`:\n```\n# JWT Configuration\nJWT_SECRET=your_secret_key_at_least_32_chars_in_production\nJWT_REFRESH_SECRET=your_refresh_secret_key_at_least_32_chars\nJWT_ACCESS_EXPIRY=15m\nJWT_REFRESH_EXPIRY=7d\nJWT_ISSUER=yuthub.com\nJWT_AUDIENCE=yuthub-api\n```\n\n### Step 2: Update Authentication Routes\n\n**Example Login Route** (`server/routes/auth.ts`):\n```typescript\nimport { enhancedJwtService } from '../services/enhancedJwtService';\n\nrouter.post('/auth/login', async (req, res) => {\n  const { email, password } = req.body;\n  \n  // Authenticate user\n  const user = await authenticateUser(email, password);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Generate tokens WITH tenant context\n  try {\n    const tokens = await enhancedJwtService.generateTokenPairWithContext(user.id);\n    \n    res.cookie('accessToken', tokens.accessToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n      maxAge: 15 * 60 * 1000,\n    });\n    \n    res.cookie('refreshToken', tokens.refreshToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n      maxAge: 7 * 24 * 60 * 60 * 1000,\n    });\n    \n    return res.json({ success: true });\n  } catch (error) {\n    return res.status(500).json({ error: 'Token generation failed' });\n  }\n});\n```\n\n### Step 3: Update Server Middleware Stack\n\n**In `server/index.ts`** (after CORS, before routes):\n```typescript\nimport { \n  extractTokenMiddleware, \n  tenantContextMiddleware,\n  handleTokenRefresh \n} from './middleware/enhancedAuthMiddleware';\n\n// ... existing middleware ...\n\n// Apply authentication middleware\napp.use(handleTokenRefresh);      // Try refresh if token missing\napp.use(extractTokenMiddleware);  // Extract JWT from Authorization header\napp.use(tenantContextMiddleware); // Inject tenant context\n\n// ... routes ...\n```\n\n### Step 4: Protect Routes with New Middleware\n\n**Example Protected Routes**:\n```typescript\nimport { \n  requireAuth, \n  requireRole, \n  requireActiveSubscription,\n  requireFeature,\n  checkOrganizationAccess \n} from './middleware/enhancedAuthMiddleware';\n\n// Basic auth required\nrouter.get('/api/user/profile', \n  requireAuth, \n  (req, res) => {\n    res.json({ user: req.user });\n  }\n);\n\n// Role-based access\nrouter.get('/api/admin/settings',\n  requireAuth,\n  requireRole(['admin', 'manager']),\n  (req, res) => { /* ... */ }\n);\n\n// Subscription-gated feature\nrouter.post('/api/features/advanced-analytics',\n  requireAuth,\n  requireActiveSubscription,\n  requireFeature('advanced_analytics'),\n  (req, res) => { /* ... */ }\n);\n\n// Multi-organization access\nrouter.get('/api/organizations/:organizationId/properties',\n  requireAuth,\n  checkOrganizationAccess,\n  (req, res) => {\n    // req.organizationId is now validated and set\n    // Query properties for this organization\n  }\n);\n```\n\n### Step 5: Update OAuth/OIDC Flows\n\n**In `server/replitAuth.ts`** (or similar):\n```typescript\nimport { enhancedJwtService } from './services/enhancedJwtService';\n\n// After user is authenticated via OIDC/OAuth:\nasync function handleOAuthCallback(profile: any) {\n  // Get or create user\n  const user = await getOrCreateUser(profile);\n  \n  // Generate tokens with tenant context\n  const tokens = await enhancedJwtService.generateTokenPairWithContext(user.id);\n  \n  return tokens;\n}\n```\n\n## Usage Patterns\n\n### Pattern 1: Accessing User Context in Routes\n\n```typescript\nrouter.get('/api/dashboard', requireAuth, (req, res) => {\n  console.log('User ID:', req.userId);\n  console.log('Organization:', req.organizationId);\n  console.log('Subscription Tier:', req.subscriptionTier);\n  console.log('User Role:', req.userRole);\n  console.log('All Organizations:', req.user?.organizations);\n  \n  // Query scoped by organization\n  const properties = await getPropertiesForOrganization(req.organizationId);\n  res.json({ properties });\n});\n```\n\n### Pattern 2: Feature-Based Access\n\n```typescript\nrouter.post('/api/advanced-search',\n  requireAuth,\n  requireFeature('advanced_search'),\n  (req, res) => {\n    // This endpoint only accessible if subscription tier includes this feature\n    res.json({ results: [] });\n  }\n);\n```\n\n### Pattern 3: Multi-Organization Navigation\n\n```typescript\nrouter.get('/api/organizations', requireAuth, (req, res) => {\n  // Return all organizations user has access to\n  res.json({ \n    primary: req.user?.primaryOrganizationId,\n    all: req.user?.organizations \n  });\n});\n\nrouter.post('/api/switch-organization/:organizationId',\n  requireAuth,\n  async (req, res) => {\n    const targetOrgId = parseInt(req.params.organizationId);\n    \n    // Verify user has access\n    const hasAccess = req.user?.organizations.some(\n      org => org.organizationId === targetOrgId\n    );\n    \n    if (!hasAccess) {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n    \n    // Optionally generate new tokens with this org as primary\n    // (requires updating user_organizations.is_primary)\n    \n    res.json({ success: true });\n  }\n);\n```\n\n### Pattern 4: Subscription Gating\n\n```typescript\nrouter.post('/api/reports/generate',\n  requireAuth,\n  requireActiveSubscription,\n  (req, res) => {\n    // Check specific feature\n    if (!req.user?.features?.['custom_reports']) {\n      return res.status(403).json({\n        error: 'Feature not available',\n        tier: req.user?.subscriptionTier,\n        upgrade: true\n      });\n    }\n    \n    // Generate report\n    res.json({ report: {} });\n  }\n);\n```\n\n## Database Queries Required\n\nThe enhanced JWT service uses the following SQL queries:\n\n### Query 1: Load Tenant Context\n```sql\nSELECT \n  uo.organization_id,\n  uo.role,\n  uo.is_primary,\n  o.name as organization_name,\n  o.subscription_tier,\n  o.subscription_status,\n  o.features_enabled\nFROM user_organizations uo\nJOIN organizations o ON o.id = uo.organization_id\nWHERE uo.user_id = $1 \n  AND uo.status = 'active' \n  AND uo.is_active = true\nORDER BY uo.is_primary DESC, uo.created_at ASC\n```\n\n### Query 2: Get User Email\n```sql\nSELECT email FROM users WHERE id = $1\n```\n\n## Performance Considerations\n\n### Database Queries\n- Tenant context is loaded ONCE per login and token refresh\n- Token contains all necessary context, avoiding N+1 queries\n- Subsequent requests use token payload, no database queries needed\n\n### Token Size\n- Access token: ~1-2KB (includes all org context)\n- Typically under HTTP header size limits (4KB)\n- If token size exceeds limits, move `organizations` array to separate token\n\n### Caching\n- Consider caching tenant context in Redis:\n  ```typescript\n  const cacheKey = `tenant:${userId}`;\n  const cached = await redis.get(cacheKey);\n  if (cached) return JSON.parse(cached);\n  ```\n\n### Refresh Token Strategy\n- Access tokens: 15 minutes (short-lived)\n- Refresh tokens: 7 days (long-lived, httpOnly cookie)\n- Token refresh reloads latest subscription/feature info\n\n## Migration Path\n\n### Phase 1: Deploy New Service\n1. Deploy `enhancedJwtService.ts` and `enhancedAuthMiddleware.ts`\n2. Keep existing auth flows intact\n3. No database changes required yet\n\n### Phase 2: Test New Flows\n1. Create new authentication route using `generateTokenPairWithContext`\n2. Test with new middleware chain\n3. Validate token payload contains all expected fields\n\n### Phase 3: Gradual Migration\n1. Update one auth endpoint at a time\n2. Use feature flags to control rollout\n3. Monitor token generation performance\n\n### Phase 4: Complete Migration\n1. Update all auth endpoints\n2. Remove legacy JWT service calls\n3. Update all route protection middleware\n\n## Troubleshooting\n\n### Issue: \"No active organizations found for user\"\n**Cause**: User has no entries in `user_organizations` or all are inactive\n**Solution**: Ensure user is added to at least one organization with `is_active=true` and `status='active'`\n\n### Issue: Token contains missing fields\n**Cause**: Database schema missing expected columns\n**Solution**: Verify `organizations` and `user_organizations` tables have all required columns\n\n### Issue: Feature checks not working\n**Cause**: `features_enabled` column is NULL or not properly formatted\n**Solution**: Ensure `features_enabled` is a JSONB object like `{\"advanced_search\": true}`\n\n### Issue: Organization access denied unexpectedly\n**Cause**: Organization ID from request doesn't match user's organizations\n**Solution**: Use `req.user?.organizations` to check available orgs\n\n## Security Best Practices\n\n1. **Secret Rotation**: Implement JWT secret rotation strategy\n2. **Token Blacklist**: Implement logout by maintaining token blacklist\n3. **HTTPS Only**: Use secure cookies (`secure: true`) in production\n4. **Rate Limiting**: Limit token generation/refresh endpoints\n5. **Audit Logging**: Log all token generation events\n6. **Scope Minimization**: Only include necessary claims in tokens\n\n## Testing\n\n### Unit Tests Example\n```typescript\nimport { enhancedJwtService } from '../services/enhancedJwtService';\n\ndescribe('Enhanced JWT Service', () => {\n  it('should load tenant context with organizations', async () => {\n    const payload = await enhancedJwtService.loadTenantContext('user123');\n    expect(payload).toBeDefined();\n    expect(payload?.organizations).toHaveLength(2);\n    expect(payload?.subscriptionTier).toBe('professional');\n  });\n\n  it('should generate token with tenant context', async () => {\n    const tokens = await enhancedJwtService.generateTokenPairWithContext('user123');\n    const decoded = enhancedJwtService.decodeToken(tokens.accessToken);\n    expect(decoded.primaryOrganizationId).toBe(1);\n    expect(decoded.organizations).toHaveLength(2);\n  });\n\n  it('should verify and decode token correctly', () => {\n    // Test with sample token\n  });\n});\n```\n\n## Next Steps\n\n1. ✅ Deploy enhanced JWT service\n2. ✅ Deploy enhanced auth middleware\n3. Update authentication routes to use `generateTokenPairWithContext`\n4. Protect API routes with new middleware\n5. Update OAuth/OIDC flows\n6. Implement token refresh logic\n7. Add monitoring and logging\n8. Run comprehensive tests\n9. Deploy to production with feature flag\n10. Monitor token sizes and database load\n"