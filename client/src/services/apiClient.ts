/**\n * API Client with multi-tenant support and automatic token refresh\n * Handles authentication, authorization, and tenant context\n */\n\ninterface RequestOptions extends RequestInit {\n  organizationId?: number;\n  retryCount?: number;\n}\n\ninterface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  meta?: {\n    timestamp: string;\n    organizationId?: number;\n  };\n}\n\nclass APIClient {\n  private baseURL: string;\n  private accessToken: string | null = null;\n  private refreshPromise: Promise<boolean> | null = null;\n  private readonly maxRetries = 3;\n  private readonly retryDelay = 1000; // ms\n\n  constructor(baseURL: string = process.env.REACT_APP_API_URL || 'http://localhost:5000') {\n    this.baseURL = baseURL;\n    this.accessToken = localStorage.getItem('access_token');\n  }\n\n  /**\n   * Get current access token\n   */\n  private getAccessToken(): string | null {\n    return this.accessToken || localStorage.getItem('access_token');\n  }\n\n  /**\n   * Set access token (called after login/refresh)\n   */\n  public setAccessToken(token: string): void {\n    this.accessToken = token;\n    localStorage.setItem('access_token', token);\n  }\n\n  /**\n   * Clear authentication\n   */\n  public clearAuth(): void {\n    this.accessToken = null;\n    localStorage.removeItem('access_token');\n  }\n\n  /**\n   * Refresh access token using refresh token (stored in httpOnly cookie)\n   */\n  private async refreshToken(): Promise<boolean> {\n    // Prevent multiple simultaneous refresh attempts\n    if (this.refreshPromise) {\n      return this.refreshPromise;\n    }\n\n    this.refreshPromise = (async () => {\n      try {\n        const response = await fetch(`${this.baseURL}/auth/refresh`, {\n          method: 'POST',\n          credentials: 'include', // Include cookies (refresh token)\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        if (!response.ok) {\n          throw new Error('Token refresh failed');\n        }\n\n        const data: ApiResponse<{ accessToken: string }> = await response.json();\n\n        if (data.data?.accessToken) {\n          this.setAccessToken(data.data.accessToken);\n          return true;\n        }\n\n        return false;\n      } catch (error) {\n        console.error('Token refresh error:', error);\n        this.clearAuth();\n        // Redirect to login on auth failure\n        window.location.href = '/login';\n        return false;\n      } finally {\n        this.refreshPromise = null;\n      }\n    })();\n\n    return this.refreshPromise;\n  }\n\n  /**\n   * Make HTTP request with automatic token refresh\n   */\n  public async request<T = any>(\n    endpoint: string,\n    options: RequestOptions = {}\n  ): Promise<T> {\n    const { organizationId, retryCount = 0, ...fetchOptions } = options;\n\n    const url = `${this.baseURL}${endpoint}`;\n    const headers = new Headers(fetchOptions.headers);\n\n    // Add auth header\n    const token = this.getAccessToken();\n    if (token) {\n      headers.set('Authorization', `Bearer ${token}`);\n    }\n\n    // Add organization context for multi-tenant queries\n    if (organizationId) {\n      headers.set('X-Organization-Id', organizationId.toString());\n    }\n\n    // Add content type if not already set\n    if (!headers.has('Content-Type') && !(fetchOptions.body instanceof FormData)) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    try {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        headers,\n        credentials: 'include', // Include cookies for refresh token\n      });\n\n      // Handle unauthorized - attempt token refresh\n      if (response.status === 401 && retryCount < this.maxRetries) {\n        const refreshed = await this.refreshToken();\n        if (refreshed) {\n          // Retry request with new token\n          await new Promise(resolve => setTimeout(resolve, this.retryDelay));\n          return this.request<T>(endpoint, {\n            ...options,\n            retryCount: retryCount + 1,\n          });\n        }\n      }\n\n      // Handle other error responses\n      if (!response.ok) {\n        const error = await response.json().catch(() => ({}));\n        throw new Error(\n          error.error || `HTTP ${response.status}: ${response.statusText}`\n        );\n      }\n\n      // Parse response\n      const data: ApiResponse<T> = await response.json();\n\n      if (!data.success) {\n        throw new Error(data.error || 'Request failed');\n      }\n\n      return data.data as T;\n    } catch (error) {\n      console.error('API request error:', {\n        endpoint,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * GET request\n   */\n  public get<T = any>(endpoint: string, options?: RequestOptions): Promise<T> {\n    return this.request<T>(endpoint, {\n      ...options,\n      method: 'GET',\n    });\n  }\n\n  /**\n   * POST request\n   */\n  public post<T = any>(\n    endpoint: string,\n    body?: any,\n    options?: RequestOptions\n  ): Promise<T> {\n    return this.request<T>(endpoint, {\n      ...options,\n      method: 'POST',\n      body: body ? JSON.stringify(body) : undefined,\n    });\n  }\n\n  /**\n   * PUT request\n   */\n  public put<T = any>(\n    endpoint: string,\n    body?: any,\n    options?: RequestOptions\n  ): Promise<T> {\n    return this.request<T>(endpoint, {\n      ...options,\n      method: 'PUT',\n      body: body ? JSON.stringify(body) : undefined,\n    });\n  }\n\n  /**\n   * PATCH request\n   */\n  public patch<T = any>(\n    endpoint: string,\n    body?: any,\n    options?: RequestOptions\n  ): Promise<T> {\n    return this.request<T>(endpoint, {\n      ...options,\n      method: 'PATCH',\n      body: body ? JSON.stringify(body) : undefined,\n    });\n  }\n\n  /**\n   * DELETE request\n   */\n  public delete<T = any>(endpoint: string, options?: RequestOptions): Promise<T> {\n    return this.request<T>(endpoint, {\n      ...options,\n      method: 'DELETE',\n    });\n  }\n}\n\n// Export singleton instance\nexport const apiClient = new APIClient();\n\n// Export for testing\nexport default APIClient;\n