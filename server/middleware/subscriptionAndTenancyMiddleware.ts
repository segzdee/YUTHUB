/**\n * Subscription and Multi-Tenancy Middleware\n * Enforces subscription-based access control and organization data isolation\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { sql } from 'drizzle-orm';\nimport {\n  SubscriptionTier,\n  SubscriptionStatus,\n  SUBSCRIPTION_TIERS,\n  MODULE_ACCESS,\n  LIMIT_ALERT_THRESHOLDS,\n  tierHasFeature,\n} from '../constants/subscriptionTiers';\n\nexport interface EnhancedSubscriptionInfo {\n  // Organization\n  organizationId: number;\n  organizationName: string;\n\n  // Subscription\n  subscriptionTier: SubscriptionTier;\n  subscriptionStatus: SubscriptionStatus;\n  billingCycle: 'monthly' | 'annual';\n\n  // Dates\n  subscriptionStartDate: Date | null;\n  subscriptionEndDate: Date | null;\n  trialEndDate: Date | null;\n\n  // Features & Limits\n  features: Record<string, boolean>;\n  maxResidents: number;\n  maxProperties: number;\n  currentResidentCount: number;\n  currentPropertyCount: number;\n  residentUsagePercent: number;\n  propertyUsagePercent: number;\n\n  // User Role within Organization\n  userRole: 'admin' | 'manager' | 'staff' | 'resident' | 'support_worker';\n  isOrgAdmin: boolean;\n  isPrimaryOrganization: boolean;\n\n  // Stripe\n  stripeCustomerId: string | null;\n  nextBillingDate: Date | null;\n\n  // Alerting\n  hasResidentUsageAlert: boolean;\n  hasPropertyUsageAlert: boolean;\n}\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      organizationId?: number;\n      subscription?: EnhancedSubscriptionInfo;\n      userRole?: string;\n      tenant?: EnhancedSubscriptionInfo; // Alternative naming for clarity\n    }\n  }\n}\n\n/**\n * Load enhanced subscription and organization info for authenticated user\n * Replaces the simpler loadSubscriptionInfo middleware\n */\nexport async function loadEnhancedSubscriptionInfo(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  try {\n    const userId = (req as any).user?.id;\n\n    if (!userId) {\n      return next();\n    }\n\n    // Query user's organization(s) with subscription details\n    const result = await db.execute(sql`\n      SELECT\n        o.id as organization_id,\n        o.name as organization_name,\n        o.subscription_tier,\n        o.subscription_status,\n        o.billing_cycle,\n        o.subscription_start_date,\n        o.subscription_end_date,\n        o.trial_end_date,\n        o.features_enabled,\n        o.max_residents,\n        o.max_properties,\n        o.current_resident_count,\n        o.current_property_count,\n        o.stripe_customer_id,\n        o.next_billing_date,\n        o.usage_alert_sent,\n        uo.role as user_role,\n        uo.is_primary,\n        CASE\n          WHEN uo.role = 'admin' THEN true\n          ELSE false\n        END as is_admin\n      FROM user_organizations uo\n      JOIN organizations o ON o.id = uo.organization_id\n      WHERE uo.user_id = ${userId}\n        AND uo.status = 'active'\n        AND uo.is_active = true\n      ORDER BY uo.is_primary DESC, uo.created_at ASC\n      LIMIT 1\n    `);\n\n    if (result.rows && result.rows.length > 0) {\n      const org = result.rows[0] as any;\n      const now = new Date();\n\n      // Determine actual subscription status\n      let subscriptionStatus = org.subscription_status as SubscriptionStatus;\n\n      // Check if trial has expired\n      if (\n        org.subscription_tier === 'trial' &&\n        org.trial_end_date &&\n        new Date(org.trial_end_date) < now\n      ) {\n        subscriptionStatus = 'cancelled';\n      }\n\n      // Check if subscription has ended\n      if (\n        org.subscription_end_date &&\n        new Date(org.subscription_end_date) < now &&\n        subscriptionStatus === 'active'\n      ) {\n        subscriptionStatus = 'cancelled';\n      }\n\n      // Calculate usage percentages\n      const residentUsagePercent =\n        org.max_residents > 0\n          ? (org.current_resident_count / org.max_residents) * 100\n          : 0;\n      const propertyUsagePercent =\n        org.max_properties > 0\n          ? (org.current_property_count / org.max_properties) * 100\n          : 0;\n\n      // Determine if usage alerts should be sent\n      const hasResidentUsageAlert =\n        residentUsagePercent >= LIMIT_ALERT_THRESHOLDS.warning * 100;\n      const hasPropertyUsageAlert =\n        propertyUsagePercent >= LIMIT_ALERT_THRESHOLDS.warning * 100;\n\n      const subscriptionInfo: EnhancedSubscriptionInfo = {\n        organizationId: org.organization_id,\n        organizationName: org.organization_name,\n        subscriptionTier: org.subscription_tier,\n        subscriptionStatus,\n        billingCycle: org.billing_cycle || 'monthly',\n        subscriptionStartDate: org.subscription_start_date\n          ? new Date(org.subscription_start_date)\n          : null,\n        subscriptionEndDate: org.subscription_end_date\n          ? new Date(org.subscription_end_date)\n          : null,\n        trialEndDate: org.trial_end_date\n          ? new Date(org.trial_end_date)\n          : null,\n        features: org.features_enabled || {},\n        maxResidents: org.max_residents,\n        maxProperties: org.max_properties,\n        currentResidentCount: org.current_resident_count || 0,\n        currentPropertyCount: org.current_property_count || 0,\n        residentUsagePercent,\n        propertyUsagePercent,\n        userRole: org.user_role,\n        isOrgAdmin: org.is_admin,\n        isPrimaryOrganization: org.is_primary,\n        stripeCustomerId: org.stripe_customer_id,\n        nextBillingDate: org.next_billing_date\n          ? new Date(org.next_billing_date)\n          : null,\n        hasResidentUsageAlert,\n        hasPropertyUsageAlert,\n      };\n\n      req.subscription = subscriptionInfo;\n      req.tenant = subscriptionInfo; // Alias for clarity\n      req.organizationId = org.organization_id;\n      req.userRole = org.user_role;\n    }\n\n    next();\n  } catch (error) {\n    console.error('Error loading subscription info:', error);\n    // Don't block request on error, but log it\n    next();\n  }\n}\n\n/**\n * Require active subscription for endpoint access\n */\nexport function requireActiveSubscription(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void {\n  if (!req.subscription) {\n    return res.status(403).json({\n      error: 'NO_SUBSCRIPTION',\n      message: 'No active subscription found. Please subscribe to continue.',\n    });\n  }\n\n  const { subscriptionStatus, subscriptionTier } = req.subscription;\n\n  // Allow trial and active subscriptions\n  if (\n    subscriptionStatus === 'cancelled' ||\n    subscriptionStatus === 'past_due'\n  ) {\n    return res.status(403).json({\n      error: 'SUBSCRIPTION_INACTIVE',\n      message:\n        subscriptionStatus === 'past_due'\n          ? 'Payment is overdue. Please update your payment method to continue.'\n          : 'Your subscription has ended. Please renew to continue.',\n      subscriptionStatus,\n      subscriptionTier,\n      requiredAction: 'renew_subscription',\n    });\n  }\n\n  next();\n}\n\n/**\n * Require specific feature access\n */\nexport function requireFeature(featureName: string) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.subscription) {\n      return res.status(403).json({\n        error: 'NO_SUBSCRIPTION',\n        message: 'Please subscribe to access this feature.',\n      });\n    }\n\n    const { subscriptionTier, features } = req.subscription;\n\n    if (features[featureName] !== true) {\n      return res.status(403).json({\n        error: 'FEATURE_NOT_AVAILABLE',\n        message: `This feature is not available in your ${subscriptionTier} plan.`,\n        featureName,\n        currentTier: subscriptionTier,\n        requiredUpgrade: true,\n        upgradeSuggestion: 'professional', // Could be dynamic based on feature\n      });\n    }\n\n    next();\n  };\n}\n\n/**\n * Require minimum subscription tier\n */\nexport function requireMinimumTier(\n  minimumTier: SubscriptionTier\n) {\n  const tierHierarchy: Record<SubscriptionTier, number> = {\n    trial: 0,\n    starter: 1,\n    professional: 2,\n    enterprise: 3,\n  };\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.subscription) {\n      return res.status(403).json({\n        error: 'NO_SUBSCRIPTION',\n        message: 'Please subscribe to access this feature.',\n      });\n    }\n\n    const { subscriptionTier } = req.subscription;\n    const userTierLevel = tierHierarchy[subscriptionTier] ?? 0;\n    const requiredTierLevel = tierHierarchy[minimumTier];\n\n    if (userTierLevel < requiredTierLevel) {\n      return res.status(403).json({\n        error: 'INSUFFICIENT_TIER',\n        message: `This feature requires ${minimumTier} plan or higher.`,\n        currentTier: subscriptionTier,\n        requiredTier: minimumTier,\n        requiredUpgrade: true,\n      });\n    }\n\n    next();\n  };\n}\n\n/**\n * Require specific user role within organization\n */\nexport function requireOrgRole(\n  allowedRoles: string | string[]\n) {\n  const roles = Array.isArray(allowedRoles) ? allowedRoles : [allowedRoles];\n\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.subscription) {\n      return res.status(403).json({\n        error: 'NOT_MEMBER',\n        message: 'You are not a member of this organization.',\n      });\n    }\n\n    const { userRole } = req.subscription;\n\n    if (!roles.includes(userRole)) {\n      return res.status(403).json({\n        error: 'INSUFFICIENT_ROLE',\n        message: `This action requires one of these roles: ${roles.join(', ')}`,\n        currentRole: userRole,\n        requiredRoles: roles,\n      });\n    }\n\n    next();\n  };\n}\n\n/**\n * Check module/page access based on subscription tier\n */\nexport function requireModuleAccess(moduleName: string) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.subscription) {\n      return res.status(403).json({\n        error: 'NO_SUBSCRIPTION',\n        message: 'Please subscribe to access this module.',\n      });\n    }\n\n    const { subscriptionTier } = req.subscription;\n    const moduleAccessMap = MODULE_ACCESS[moduleName as keyof typeof MODULE_ACCESS];\n\n    if (!moduleAccessMap) {\n      // Module not found in access map, allow access\n      return next();\n    }\n\n    if (!moduleAccessMap[subscriptionTier]) {\n      return res.status(403).json({\n        error: 'MODULE_NOT_AVAILABLE',\n        message: `The ${moduleName} module is not available in your ${subscriptionTier} plan.`,\n        module: moduleName,\n        currentTier: subscriptionTier,\n        requiredUpgrade: true,\n      });\n    }\n\n    next();\n  };\n}\n\n/**\n * Check resident limit before allowing resident creation/addition\n */\nexport function requireResidentCapacity(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void {\n  if (!req.subscription) {\n    return res.status(403).json({\n      error: 'NO_SUBSCRIPTION',\n      message: 'Please subscribe to continue.',\n    });\n  }\n\n  const { maxResidents, currentResidentCount } = req.subscription;\n\n  // Unlimited tier (-1) always allows\n  if (maxResidents < 0) {\n    return next();\n  }\n\n  if (currentResidentCount >= maxResidents) {\n    return res.status(403).json({\n      error: 'RESIDENT_LIMIT_REACHED',\n      message: `You have reached your resident limit (${maxResidents}).`,\n      currentCount: currentResidentCount,\n      maxAllowed: maxResidents,\n      requiredUpgrade: true,\n    });\n  }\n\n  next();\n}\n\n/**\n * Check property limit before allowing property creation\n */\nexport function requirePropertyCapacity(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void {\n  if (!req.subscription) {\n    return res.status(403).json({\n      error: 'NO_SUBSCRIPTION',\n      message: 'Please subscribe to continue.',\n    });\n  }\n\n  const { maxProperties, currentPropertyCount } = req.subscription;\n\n  // Unlimited tier (-1) always allows\n  if (maxProperties < 0) {\n    return next();\n  }\n\n  if (currentPropertyCount >= maxProperties) {\n    return res.status(403).json({\n      error: 'PROPERTY_LIMIT_REACHED',\n      message: `You have reached your property limit (${maxProperties}).`,\n      currentCount: currentPropertyCount,\n      maxAllowed: maxProperties,\n      requiredUpgrade: true,\n    });\n  }\n\n  next();\n}\n\n/**\n * Enforce multi-tenancy: ensure organizationId in request matches user's organization\n * This prevents users from accessing data from organizations they don't belong to\n */\nexport function enforceMultiTenancy(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void {\n  if (!req.subscription) {\n    return res.status(403).json({\n      error: 'NOT_MEMBER',\n      message: 'You do not have access to this organization.',\n    });\n  }\n\n  // Get organizationId from query params, request body, or URL params\n  const requestedOrgId = parseInt(\n    req.query.organizationId as string ||\n    req.body?.organizationId ||\n    req.params.organizationId ||\n    '0'\n  );\n\n  // If no organizationId specified, use user's primary organization\n  if (!requestedOrgId) {\n    req.organizationId = req.subscription.organizationId;\n    return next();\n  }\n\n  // Verify user belongs to the requested organization\n  if (requestedOrgId !== req.subscription.organizationId) {\n    return res.status(403).json({\n      error: 'ORGANIZATION_MISMATCH',\n      message: 'You do not have access to this organization.',\n      requestedOrganization: requestedOrgId,\n      allowedOrganization: req.subscription.organizationId,\n    });\n  }\n\n  req.organizationId = requestedOrgId;\n  next();\n}\n"